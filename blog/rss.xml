<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>J. Gulan Blog</title>
        <link>https://jgulan.dev/blog</link>
        <description>J. Gulan Blog</description>
        <lastBuildDate>Sun, 15 Jan 2023 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <item>
            <title><![CDATA[Detecting Regression Commits Using git bisect]]></title>
            <link>https://jgulan.dev/blog/2023/01/15/detecting-regression-commits-using-git-bisect</link>
            <guid>/2023/01/15/detecting-regression-commits-using-git-bisect</guid>
            <pubDate>Sun, 15 Jan 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Locating the commit that introduced a regression, or some undesirable change, in a codebase can be difficult. Locating the same in a frequently-changing codebase with a large number of contributors is harder again.]]></description>
            <content:encoded><![CDATA[<p>Locating the commit that introduced a regression, or some undesirable change, in a codebase can be difficult. Locating the same in a frequently-changing codebase with a large number of contributors is harder again.</p><p>Fortunately <a href="https://git-scm.com/docs/git-bisect" target="_blank" rel="noopener noreferrer"><code>git bisect</code></a> provides a helpful tool for doing precisely this. Rather than performing a linear search of the commits, <code>git bisect</code> uses a clever binary search algorithm to locate the offending commit far more efficiently.</p><p>Having identified a commit from the past where the regression did not exist (e.g. <code>git checkout</code> a commit from say a month ago), my typical usage of <code>git bisect</code> is along the lines of:</p><ol><li>Check out the branch containing the regression and run <code>git bisect start</code>.</li><li>Label the good and bad commits: <code>git bisect good &lt;commit hash&gt;</code> and <code>git bisect bad &lt;commit hash&gt;</code>. The current commit is taken if the commit hash argument is omitted.</li><li>Bisecting commences — a candidate commit is automatically checked out and the number of revisions left to test and number of remaining steps are printed.  You can run <code>git bisect reset</code> to abort at any stage.</li><li>Check whether the regression still exists, whether this involves running an automated test or taking manual replication steps. If the candidate commit contains the regression, run <code>git bisect bad</code>, otherwise run <code>git bisect good</code>. If any search area remains, another candidate commit is automatically checked out.</li><li>Repeat until the bisecting process concludes and the bad commit's hash is listed.</li></ol><p>Given <code>git bisect</code>'s binary search technique, the number of steps required will only increase logarithmically as the number of commits increases — this is a time-saving tool that I turn to again and again.</p>]]></content:encoded>
            <category>engineering</category>
        </item>
        <item>
            <title><![CDATA[Placeholder]]></title>
            <link>https://jgulan.dev/blog/2023/01/13/placeholder</link>
            <guid>/2023/01/13/placeholder</guid>
            <pubDate>Fri, 13 Jan 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[...]]></description>
            <content:encoded><![CDATA[<p>...</p>]]></content:encoded>
        </item>
    </channel>
</rss>
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jgulan.dev/blog</id>
    <title>J. Gulan Blog</title>
    <updated>2023-01-15T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jgulan.dev/blog"/>
    <subtitle>J. Gulan Blog</subtitle>
    <icon>https://jgulan.dev/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[Detecting Regression Commits Using git bisect]]></title>
        <id>/2023/01/15/detecting-regression-commits-using-git-bisect</id>
        <link href="https://jgulan.dev/blog/2023/01/15/detecting-regression-commits-using-git-bisect"/>
        <updated>2023-01-15T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Locating the commit that introduced a regression, or some undesirable change, in a codebase can be difficult. Locating the same in a frequently-changing codebase with a large number of contributors is harder again.]]></summary>
        <content type="html"><![CDATA[<p>Locating the commit that introduced a regression, or some undesirable change, in a codebase can be difficult. Locating the same in a frequently-changing codebase with a large number of contributors is harder again.</p><p>Fortunately <a href="https://git-scm.com/docs/git-bisect" target="_blank" rel="noopener noreferrer"><code>git bisect</code></a> provides a helpful tool for doing precisely this. Rather than performing a linear search of the commits, <code>git bisect</code> uses a clever binary search algorithm to locate the offending commit far more efficiently.</p><p>Having identified a commit from the past where the regression did not exist (e.g. <code>git checkout</code> a commit from say a month ago), my typical usage of <code>git bisect</code> is along the lines of:</p><ol><li>Check out the branch containing the regression and run <code>git bisect start</code>.</li><li>Label the good and bad commits: <code>git bisect good &lt;commit hash&gt;</code> and <code>git bisect bad &lt;commit hash&gt;</code>. The current commit is taken if the commit hash argument is omitted.</li><li>Bisecting commences — a candidate commit is automatically checked out and the number of revisions left to test and number of remaining steps are printed.  You can run <code>git bisect reset</code> to abort at any stage.</li><li>Check whether the regression still exists, whether this involves running an automated test or taking manual replication steps. If the candidate commit contains the regression, run <code>git bisect bad</code>, otherwise run <code>git bisect good</code>. If any search area remains, another candidate commit is automatically checked out.</li><li>Repeat #4 until the bisecting process concludes and the bad commit's hash is listed.</li></ol><p>Given <code>git bisect</code>'s binary search technique, the number of steps required will only increase logarithmically as the number of commits increases — this is a time-saving tool that I turn to again and again.</p>]]></content>
        <category label="engineering" term="engineering"/>
    </entry>
</feed>
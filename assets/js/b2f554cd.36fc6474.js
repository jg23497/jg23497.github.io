"use strict";(self.webpackChunkjgulan=self.webpackChunkjgulan||[]).push([[477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/2023/01/15/detecting-regression-commits-using-git-bisect","metadata":{"permalink":"/blog/2023/01/15/detecting-regression-commits-using-git-bisect","source":"@site/blog/2023/01-15-detecting-regression-commits-using-git-bisect/index.md","title":"Detecting Regression Commits Using git bisect","description":"Locating the commit that introduced a regression, or some undesirable change, in a codebase can be difficult. Locating the same in a frequently-changing codebase with a large number of contributors is harder again.","date":"2023-01-15T00:00:00.000Z","formattedDate":"January 15, 2023","tags":[{"label":"engineering","permalink":"/blog/tags/engineering"}],"readingTime":1.445,"hasTruncateMarker":false,"authors":[],"frontMatter":{"title":"Detecting Regression Commits Using git bisect","tags":["engineering"]}},"content":"import VisualisationSvg from \\"./git-bisect.svg\\";\\n\\nLocating the commit that introduced a regression, or some undesirable change, in a codebase can be difficult. Locating the same in a frequently-changing codebase with a large number of contributors is harder again.\\n\\nFortunately [`git bisect`](https://git-scm.com/docs/git-bisect) provides a helpful tool for doing precisely this. Rather than performing a linear search of the commits, `git bisect` uses a clever binary search algorithm to locate the offending commit far more efficiently.\\n\\n<div class=\\"center with-margin\\">\\n  <VisualisationSvg />\\n</div>\\n\\nHaving identified a commit from the past where the regression did not exist (e.g. `git checkout` a commit from say a month ago), my typical usage of `git bisect` is along the lines of:\\n\\n1. Check out the branch containing the regression and run `git bisect start`.\\n2. Label the good and bad commits: `git bisect good <commit hash>` and `git bisect bad <commit hash>`. The current commit is taken if the commit hash argument is omitted.\\n3. Bisecting commences \u2014 a candidate commit is automatically checked out and the number of revisions left to test and number of remaining steps are printed.  You can run `git bisect reset` to abort at any stage.\\n4. Check whether the regression still exists, whether this involves running an automated test or taking manual replication steps. If the candidate commit contains the regression, run `git bisect bad`, otherwise run `git bisect good`. If any search area remains, another candidate commit is automatically checked out.\\n5. Repeat #4 until the bisecting process concludes and the bad commit\'s hash is listed.\\n\\nGiven `git bisect`\'s binary search technique, the number of steps required will only increase logarithmically as the number of commits increases \u2014 this is a time-saving tool that I turn to again and again."}]}')}}]);
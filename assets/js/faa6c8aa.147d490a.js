"use strict";(self.webpackChunkjgulan=self.webpackChunkjgulan||[]).push([[274],{997:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>g,frontMatter:()=>o,metadata:()=>r,toc:()=>l});var n=i(7462),a=(i(7294),i(3905));const o={title:"Detecting Regression Commits Using git bisect",tags:["engineering"]},s=void 0,r={permalink:"/blog/2023/01/15/detecting-regression-commits-using-git-bisect",source:"@site/blog/2023/01-15-detecting-regression-commits-using-git-bisect/index.md",title:"Detecting Regression Commits Using git bisect",description:"Locating the commit that introduced a regression, or some undesirable change, in a codebase can be difficult. Locating the same in a frequently-changing codebase with a large number of contributors is harder again.",date:"2023-01-15T00:00:00.000Z",formattedDate:"January 15, 2023",tags:[{label:"engineering",permalink:"/blog/tags/engineering"}],readingTime:1.39,hasTruncateMarker:!1,authors:[],frontMatter:{title:"Detecting Regression Commits Using git bisect",tags:["engineering"]},nextItem:{title:"Placeholder",permalink:"/blog/2023/01/13/placeholder"}},c={authorsImageUrls:[]},l=[],m={toc:l};function g(e){let{components:t,...i}=e;return(0,a.kt)("wrapper",(0,n.Z)({},m,i,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Locating the commit that introduced a regression, or some undesirable change, in a codebase can be difficult. Locating the same in a frequently-changing codebase with a large number of contributors is harder again."),(0,a.kt)("p",null,"Fortunately ",(0,a.kt)("a",{parentName:"p",href:"https://git-scm.com/docs/git-bisect"},(0,a.kt)("inlineCode",{parentName:"a"},"git bisect"))," provides a helpful tool for doing precisely this. Rather than performing a linear search of the commits, ",(0,a.kt)("inlineCode",{parentName:"p"},"git bisect")," uses a clever binary search algorithm to locate the offending commit far more efficiently."),(0,a.kt)("p",null,"Having identified a commit from the past where the regression did not exist (e.g. ",(0,a.kt)("inlineCode",{parentName:"p"},"git checkout")," a commit from say a month ago), my typical usage of ",(0,a.kt)("inlineCode",{parentName:"p"},"git bisect")," is along the lines of:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Check out the branch containing the regression and run ",(0,a.kt)("inlineCode",{parentName:"li"},"git bisect start"),"."),(0,a.kt)("li",{parentName:"ol"},"Label the good and bad commits: ",(0,a.kt)("inlineCode",{parentName:"li"},"git bisect good <commit hash>")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"git bisect bad <commit hash>"),". The current commit is taken if the commit hash argument is omitted."),(0,a.kt)("li",{parentName:"ol"},"Bisecting commences \u2014 a candidate commit is automatically checked out and the number of revisions left to test and number of remaining steps are printed.  You can run ",(0,a.kt)("inlineCode",{parentName:"li"},"git bisect reset")," to abort at any stage."),(0,a.kt)("li",{parentName:"ol"},"Check whether the regression still exists, whether this involves running an automated test or taking manual replication steps. If the candidate commit contains the regression, run ",(0,a.kt)("inlineCode",{parentName:"li"},"git bisect bad"),", otherwise run ",(0,a.kt)("inlineCode",{parentName:"li"},"git bisect good"),". If any search area remains, another candidate commit is automatically checked out."),(0,a.kt)("li",{parentName:"ol"},"Repeat until the bisecting process concludes and the bad commit's hash is listed.")),(0,a.kt)("p",null,"Given ",(0,a.kt)("inlineCode",{parentName:"p"},"git bisect"),"'s binary search technique, the number of steps required will only increase logarithmically as the number of commits increases \u2014 this is a time-saving tool that I turn to again and again."))}g.isMDXComponent=!0}}]);